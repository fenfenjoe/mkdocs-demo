# 算法



### 常见的算法问题

* 八皇后问题
* 背包问题、0-1背包问题
* 大整数相乘 ： ab*cd=a*c*10^n + b*d + (a*c+b*d)*10^(n/2)
* 排序（选择排序、冒泡排序、快速排序、归并排序）
* 汉诺塔：n个盘子移动问题

### 算法求解的过程

1. 理解问题
2. 数学建模
3. 设计算法
4. 分析算法性能（时间复杂度、空间复杂度、正确性）


### 算法的应用
算法是计算机学科的核心。经常应用于以下的一些方向：

1. 操作系统、编译器（进程调度、词法分析）
2. 网络（路由算法、搜索引擎）
3. 人工智能（神经网络、随机森林、向量机、智能算法）
4. 密码学
5. 计算机生物学
6. 计算机图形学


### 算法的常见模式

* 穷举法（迭代法、回溯法）：列出所有可能情况。
* 贪婪法：选择当前局部最优的策略。
    * 图的最短路径算法（Dijkstra）
* 分治法：将大问题分解成小问题。
    * 斐波那契数列
    * 大整数相乘
    * 排序（选择排序、冒泡排序、快速排序、归并排序）
    * 汉诺塔
* 动态规划：分治法的一种，通过缓存子问题的结果，避免重复解决分解出来的子问题。



#### 迭代(iteration)和递归(recursion)

【什么是递归】  
函数A 会调用 函数A本身，就叫递归。其过程等同于树的深度优先遍历。  

【什么是迭代】  
函数A 调用 函数B，得到结果后再以结果为入参，继续调用B，就叫迭代。  


#### 回溯法(back tracking) 

##### 回溯法的经典问题

1. 求走出迷宫的路径  
2. 0-1背包问题

##### 常使用的数据结构

* 树
* 图

##### 概述
参考：[https://blog.csdn.net/wmy01234/article/details/106070249/](https://blog.csdn.net/wmy01234/article/details/106070249/)  

【一.解空间】  

回溯法一般对应以下类型的问题：
该问题有n个输入，所有输入可以表示成一个向量 $X = (x_1,x_2,...x_n)$  
每个分向量$x_i(1 \leq i \leq i)$的取值范围则可以用一个集合表示$S_i = \lbrace a_1,a_2,...a_{mi} \rbrace$  
**所有可能的解向量构成了问题的解空间**  

每个分向量$x_i$有$m_i$个取值。因此解空间的大小为$m=m_1 \times m_2 \times m_3 \times ... \times m_n$  

解空间中的解又叫**可能解**。  

所有符合题目的约束条件的解则叫**可行解**。  

符合题目的约束条件，同时能使目标函数取得最优的可行解，被叫**最优解**。  

【二.解空间树】  

我们可以通过构造一棵“解空间树”，来表示出解空间中的所有**可能解**。  

1. 根节点，表示解题的开始。  

2. 第二层的结点则表示对第1个分向量作出选择后达到的一个状态。第1层到第2层的边上标出对第1个分向量选择的结果。  

3. 以此类推，就生成了一颗**解空间树**。从根节点一直到某一个叶子节点，构成了解空间中的一个**可能解**。  

> 解空间树的类型
> (1)子集树：当问题是**从n个元素的集合S中找出满足某种性质的子集**时，相应的解空间树被称为**子集树**。  
> (2)排列子树：当问题是**求出n个元素满足某种性质的所有排列**时，相应的解空间树被称为**排列子树**。  


```
//leetcode经典例题：括号生成
//数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

//下面是示例答案



    public static List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        getResult(0,0,n,new StringBuilder(),result);
        return result;

    }

    /**
     * 对于n组括号，递归找出有效的括号组合
     * @param openIndex 当前左括号的个数
     * @param closeIndex 当前右括号的个数
     * @param n 括号的组数
     * @param strBuf 当前字符串
     * @param result 有效的括号组合List
     */
    public static void getResult(int openIndex,int closeIndex,int n,StringBuilder strBuf,List<String> result){
        //目标状态：当前的括号组合，即strBuf

        //找出约束条件，用于对解空间树进行剪枝。
        //可以找到以下约束条件：
        //2.若左括号的个数或者右括号的个数超过n，则肯定不是有效的括号组合；
        //3.若右括号的个数比左括号个数多，则肯定不是有效的括号组合；


        //找到符合问题的解，则可以停止遍历。（由n组括号组成）
        if(strBuf.length()==2*n){
            result.add(strBuf.toString());
            return ;
        }
        //1.若左括号的个数或者右括号的个数超过n，则肯定不是有效的括号组合；
        if(openIndex<n){
            strBuf.append('(');
            getResult(openIndex+1,closeIndex,n,strBuf,result);
            strBuf.deleteCharAt(strBuf.length()-1);
        }
        //2.若右括号的个数比左括号个数多，则肯定不是有效的括号组合；
        if(closeIndex<openIndex){
            strBuf.append(')');
            getResult(openIndex,closeIndex+1,n,strBuf,result);
            strBuf.deleteCharAt(strBuf.length()-1);
        }

    }
```





#### 动态规划（dynamic programming）

动态规划问题，又简称“DP问题”。  

它是一种解题思路，一种模式；当我们发现算法题符合动态规划的解题条件时，我们便可以将算法题转化成动态规划问题。  

动态规划，就是：
1. 将我们需要解决的问题化成若干个小问题；
2. 同时找出“通过小问题的答案求出大问题”的方法。  


##### 动态规划的经典问题

1. 求一个长度为n的字符串的最长回文子串。（回文字符串：cbabc,cbbc）
2. 求一个整数数组的最大子数组和。
3. 0-1背包问题

##### 常使用的数据结构

二维数组  

##### 状态转移方程

为什么需要**状态转移方程**？  
答：  
1. 若算法问题，可以写成一个状态转移方程，则该算法基本可以用动态规划的思想去解答。  
2. 通过状态转移方程，我们可以很容易转化成我们的代码实现。


什么是状态转移方程？  
答：  
其实就是用数学（方程组）的方式，描述：
1. 我们如何将问题化成若干个小问题；
2. 我们如何通过小问题的答案求出大问题的答案。

既然要转变成方程，我们就需要找出自变量以及因变量（状态）。  

对于例题1，自变量我们可以取：字符串的长度为i的回文子串  


##### 适合用动态规划的条件

1. 无后效性
2. 最优子结构

