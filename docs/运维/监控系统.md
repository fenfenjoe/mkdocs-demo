# 监控系统

[toc]

## 监控对象

**服务器资源**
主要包括CPU利用率、内存使用情况、I/O读写量、带宽等。
**接口监控**
某个API接口的响应时间、吞吐量
**资源监控**
mysql、redis等资源的响应时间、吞吐量


## 监控指标

**响应时间（rt）**
500ms以上算慢请求。

**请求量**
又分为实时请求量和统计请求量。
实时请求量：一般用QPS（每秒查询次数）、TPS（每秒事务次数）来衡量；
统计请求量：一般用PV（Page View，一段时间内页面访问次数）来衡量。

**吞吐量**
跟请求量类似，一般用每秒处理完多少个请求来表示。

**失败数、失败比率**
接口返回404、500等失败响应的次数。

**CPU利用率**

可理解为：程序每秒占用的时间片数 / CPU所有核每秒能提供的时间片数

> **程序何时会占用CPU时间片？**
> * 当程序启动后，会变成一个“进程”被加载到内存中，其中包括程序需要运行的代码、数据。
> * 进程启动时，可能需要初始化，进程此时就会启动线程，去竞争CPU时间片来执行初始化代码。此时CPU利用率变高；
> * 初始化完后，因为没有什么任务，多数线程会被阻塞（比如需要等待IO、或者代码主动使线程阻塞等），或者闲置，就会放弃时间片的争夺。此时CPU利用率就会变低；
> * 而对于java web应用而言，当请求数量变多，web应用就需要开多的线程去竞争CPU时间片，去执行代码处理请求，此时CPU利用率就会变高。


> **线程池线程数太多、或者线程队列太长，是影响CPU多点，还是内存多一点？**
> * 首先，线程队列里的线程不竞争CPU时间片，因此不会影响CPU占用率，队列越长，占用的内存会越多，甚至会导致OOM（内存溢出）；
> * 其次，假设程序是单线程，但CPU是多核，那么即使线程死循环了，也不会使CPU占用率达到100%；
> * 若程序是多线程，且线程数大于CPU的核数，就有可能使其CPU占用率达到100%；

如果发现进程的CPU占用率过高了，就有可能是程序处理请求的时间变慢

**内存利用率**


**磁盘利用率**


**带宽利用率**




## 监控方式

|方式         |说明                                                                      |实现                                        |
|---         |---                                                                       |---                                        |
|Log         |日志，通过日志监控运行环境、程序的情况                                        |ELK（Elastic Search、Logstash、kibana）     |                                           
|Tracing     |链路，监控函数调用链路的情况                                                 |CAT                                        |
|Metrics     |度量                                                                       |Prometheus+Grafana+alertmanager+企业微信报警|
|Healthchecks|健康检查                                                                   |                                           |






## Prometheus+微服务的监控系统架构

在此讨论如下监控系统架构。

* 监控系统：“Prometheus+Grafana+alertmanager+企业微信报警”
* 监控对象：“微服务”

以下为详细的步骤。

### 搭建监控系统

使用Docker安装：可参考https://blog.csdn.net/ss810540895/article/details/116785619

#### Prometheus

一个性能指标、日志信息等数据的收集系统，有限的可视化图表功能，可将数据接入Grafana，由Grafana做图表展示。

原理：监控对象（微服务）暴露一个HTTP地址（/metric），该地址会以metric格式的消息，告诉Prometheus监控对象本身的一些情况。Prometheus通过定时轮询该地址获取这些消息。

>扩展知识：metric格式


#### Grafana

Grafana是一个跨平台的开源的度量分析和可视化工具，可以通过将采集的数据查询然后可视化的展示，并及时通知。

支持的数据源：
* Graphite
* InfluxDB
* OpenTSDB
* Prometheus
* Elasticsearch
* CloudWatch
* KairosDB

#### alertmanager
### 为微服务支持监控功能（spring-boot-actuator）

首先需要了解一下spring-boot-actuator这个依赖。


#### 端点（Endpoint）
actuator提供多种端点（Endpoint）：
* 应用配置类：用于查看微服务的应用配置、环境变量、自动化配置报告等信息；
* 度量指标类：用于查看微服务的一些性能指标。如内存信息、线程池信息、HTTP请求统计等；
* 操作控制类：用于对微服务进行关闭等操作。

##### Actuator支持哪些端点
1. 可以参考官方文档：[https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html)

2. 可新建一个微服务，并将所有监控点打开并查看。

有以下常用端点。查看方式是localhost:8080/actuator/端点名
```
/health端点：可显示微服务及所在主机的健康信息。若微服务依赖了redis、rabbitmq、db等组件，还会显示它们的健康信息。

/metrics端点：显示JVM、Web容器的状态信息。

/loggers端点：查看日志级别、不停机修改日志级别

/info端点：程序的自定义信息，默认为空。需要在配置文件中配置。

/beans端点：将Spring容器内所有bean实例的信息显示出来（包括别名、作用域scope、类等）

/heapdump端点： 调用后下载一个Jvm的堆文件heapdump。可以通过VisualJVM工具打开该文件，查看内存快照。

/threaddump端点：调用后查看当前Jvm内所有线程的情况。包括线程id、线程名、阻塞次数等。

/shutdown端点：优雅的关闭微服务。需要用POST请求。
```
如何开启端点：
```properties
#打开所有监控点
management.endpoints.web.exposure.include=*
#打开部分监控点
management.endpoints.web.exposure.exclude=beans,trace
#显示详细的健康信息
management.endpoint.health.show-details=always
#显示详细的健康信息时，显示redis的信息（默认为true）
management.health.redis.enabled=false
#自定义info信息
info.app.name=test
info.app.user=admin
```
### 微服务支持与Prometheus的对接

首先了解一下micrometer。

micrometer定义了一系列监控功能相关的接口，同时提供了对不同监控系统的支持。