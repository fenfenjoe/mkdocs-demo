# 设计模式

[toc]

## 某设计模式下的类命名
工厂模式	xxxFactory  
单例模式	xxxSingleton  
建造者模式	xxxBuilder  
原型模式	xxxPrototype  
适配器模式	xxxAdapter  
装饰模式	xxxDecorator  
代理模式	xxxFacade  
外观模式	xxxFactory  
桥接模式	xxxBridge  
组合模式	xxxComposite  
享元模式	xxxFlyweight  
策略模式	xxxStrategy  
模板方法模式	xxxTemplate  
观察者模式	xxxObserver  
迭代子模式	xxxIterator  
责任链模式	xxxChain  
命令模式	xxxCommand  
备忘录模式	xxxMemento  
状态模式	xxxState  
访问者模式	xxxVisitor  
中介者模式	xxxMediator  
解释器模式	xxxInterpreter  

## 创建型

### 单例模式	xxxSingleton
控制一个类仅能产生一个实例。  
懒汉式：类加载时不会生成实例，只有在调用时才会生成实例。  
饿汉式：类加载时便会生成实例。  


```java
/**
* 推荐实现：懒汉式-静态内部类
**/
public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}

/**
* 饿汉式-线程安全
**/
public class Singleton {

    private static Singleton uniqueInstance = new Singleton();

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        return uniqueInstance;
    }
}


/**
* 懒汉式-线程安全-双重校验锁
**/
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}


/**
* 懒汉式-线程不安全
**/
public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}
```

### 工厂模式	xxxFactory
负责创建、管理某些对象实例。调用者无需手动new，而是调用工厂类获取实例对象即可。

**举例：**
Spring中，将所有需要管理的类都看作“Bean”，这些类对象的创建、管理则交由“BeanFactory”来管理。
```java

```
### 建造者模式	xxxBuilder

### 原型模式	xxxPrototype
为对象增加拷贝的功能：Clonable接口

还要考虑以下问题：
* 是否需要深拷贝
* 使用哪种拷贝方式（JDK自带、CGLIB等）

> 现在已有很多工具包支持对象拷贝。  
> 浅拷贝：  
> 1. org.springframework.beans.BeanUtils.copyProperties(obj, target);  
> 
> 深拷贝：  
> 1. 实现Clonable接口，并重载对象的clone()方法（略）  
> 2. Common包-序列化（user需要序列化）  
>    org.apache.commons.lang3.SerializationUtils.clone(user)  
> 3. GSON序列化（Json）  
>    Gson gson = new Gson();  
>    UserGson copyUser = gson.fromJson(gson.toJson(user), UserGson.class);
> 4. Jackson  
>    ObjectMapper objectMapper = new ObjectMapper();  
>    UserJackson copyUser = objectMapper.readValue(objectMapper.writeValueAsString(user), UserJackson.class);


## 结构型
### 适配器模式	xxxAdapter
**使用场景：**
客户要为某个类A添加某个功能，而类B有该功能的实现。

**解决方法：**
新建一个类C（Adapter），类C为类A的子类，然后在类C中组合类B，并暴露类B该功能的实现。此时类C便为适配器。
一般类C会被命名为“ClassAAdatper”。

**代码示例：**
```java
public class ClassA{

}

class ClassB{
  public void function();
}

public class ClassC extends ClassA{
  private ClassB classB;
  
  public void function(){
    classB.function();
  }
}
```

**应用：**
SpringBootSecurity中的：WebSecurityConfigurerAdapter






### 装饰模式	xxxDecorator
### 代理模式	xxxProxy
### 外观模式（门面模式）	xxxFacade
**场景：**
当客户需要调用不同的函数，但这些函数都来自不同的系统（类），为避免麻烦，通过一个外观类来封装、管理这些系统（类），为客户隐藏子系统的细节。

**示例：**
```java
/**外观类**/
public class SystemFacade{
    private System1 system1;
    private System2 system2;

    public void operation1(){
      system1.operation1();
    }

    public void operation2(){
      system2.operation2();
    }
}

class System1{
    public void operation1();
}
class System2{
    public void operation2();
}
```

### 桥接模式	xxxBridge
**作用：**
当一个类的对象有很多不同维度的属性时，通过“组合”而非“继承”的方式去构建该类。

**示例：**
比如“衣服”类，有以下不同的维度：
尺寸：S、M、L...
类型：长袖、POLO、短袖...
质地：丝质、羽绒...

**错误示例**
S码长袖丝质建一个类、M码长袖丝质建一个类...

**正确做法**
为每个维度抽象出一个接口（尺寸：Size、类型：Type、质地：Texture）；
衣服类包含（组合）这些维度作为属性。
```java
public class Cloth{
private Size size;
private Type type;
private Texture texture;
}
```
### 组合模式	xxxComposite
**作用：**
一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性。

**角色：**
Component接口：客户访问对象的接口，客户无需关心调用的是单个对象还是组合对象；

Leaf：实现了Component接口

Branch：实现了Component接口，同时还有增、删、改Component的一些API，用于构建树状结构

**应用：购物袋**
Leaf是商品，Branch是购物袋，Component提供了结账的方法。



### 享元模式	xxxFlyweight
**作用：**
当某个类需要被创建大量相似的对象时，会带来大量的内存开销。享元模式便是用来解决该问题。

通过将对象中相同的、不变的部分分离出来共享，来减少数据冗余，节省内存开销。

**角色：**
Flyweight：享元角色，即对象之间共享的部分。

UnsharedConcreteFlyweight：非享元角色，即对象之间不一样的部分。

**示例：五子棋**
**棋子类包含“落子”方法，每颗棋子一样，因此为享元角色；**
**而落的位置每个棋子不同，因此再分出一个非享元角色Point类，表示位置**
![b36b79987e2bebf5332afb2175175fff.png](en-resource://database/1096:1)


## 行为型
### 模板方法模式	xxxTemplate
**场景：**
某个函数有一个固定的流程，流程按一定的步骤进行；但这些步骤的具体实现不确定，或者说可以被修改。

例如“银行办理业务”，分为“取号”、“排队”、“办理业务”、“评价服务”几个步骤。其中“取号”可以“现场取”、“手机取”；“办理业务”可以是“取款”、“存款”等等。

**做法：**
同样拿银行办理业务作例子。
定义一个抽象类，其中runBusiness定义了办理业务的固定流程，其余四个方法由子类去实现。
```java
public abstract class BussinessTemplate{
  /**办理业务的抽象流程**/
  public void runBusiness(){
      getNum();
      inQueue();
      doBusiness();
      judgeService();
  }
  /**下面的步骤因为不固定，因此定义为抽象方法。
  若步骤是明确且固定不变的，则可直接在此实现，不用定义为抽象方法。**/
  /**取号**/
  protected abstract void getNum();
  /**排队**/
  protected abstract void inQueue();
  /**办理业务**/
  protected abstract void doBusiness();
  /**评价服务**/
  protected abstract void judgeService();
}

```
若要写一个“存款”的流程，则只需继承上面这个BussinessTemplate抽象类，并实现里面的抽象方法即可。

### 观察者模式	xxxObserver
**场景：**
当某个事件发生后，一些类需要对该事件进行响应（我们称为观察者）。
```java
public class Client{
  public void func(){
    //...
    
    //事件发生
    if(event.success){
        //观察者类对事件进行响应
        classA.responseEvent();
        classB.responseEvent();
        //...
    }
  }
}
```
这样写会非常麻烦，若事件在其他代码里面也会发生，那么当需要增删观察者时，就要改很多地方。此时，观察者模式发挥作用。

我们可定义一个“观察者注册中心”类，维护观察者列表；当事件发生后，由该注册中心统一通知观察者去响应。
```java
/**观察者注册中心**/
public class MyObservable extends Observable{

    List<Observer> list;
    boolean isChange;
    
    /**添加观察者**/
    void addObserver(Observer o){

    }
    
    /**通知观察者**/
    void notifyObservers(Object arg){
    
    }
    
    /**设置修改标志，当标志改变时，才通知观察者**/
    void setChange(){
    }
}

/**观察者**/
public class MyObserver extends Observer{
  void update(Observable o,Object arg) {
    //...
  }
}

```
其中，Observable和Observer都是JAVA提供的观察者模式的API。


### 策略模式	xxxStrategy
**作用：**
若函数中某个地方可以有不同的策略去解决，则可以将这些策略抽象成接口。
```java
public class Test{
  Strategy strategy;
  
  public void main(String[] args){
    //先选择具体的策略，再执行函数
    setStrategy(new MyStrategy());
    func();
  }
  
  public void func(){
  //...
  //此处则省略了ifelse去选择策略的代码
  strategy.execute();
  //...
  }
  
  public void setStrategy(Strategy strategy){
   this.strategy=strategy;
  }
}
```



### 解释器模式	xxxInterpreter
### 责任链模式	xxxChain
### 迭代子模式	xxxIterator
### 命令模式	xxxCommand
**作用：**
将请求封装为一个对象，请求者与执行者之间通过命令对象进行沟通；
方便对请求进行储存、传递、管理；
配合组合模式：可实现组合命令，即宏命令；
配合备忘录模式：可实现命令的撤销、恢复；

**场景：**
如餐馆内餐牌上的每道菜，就是一个命令。

### 备忘录模式	xxxMemento
该模式又被称为“快照模式”。

**作用：**
若有一个需求：用户可撤销某个函数的执行结果，回到上一步（类似于文本编辑时的Ctrl+Z），则可用到备忘录模式。

**示例：**
```java
/**用户**/
public class User{

    private String state;

    public void setState(String state) {this.state = state;}

    public String getState() {return state;}
    /**创建备忘录**/
    public Memento createMemento() {
        return new Memento(state);
    }
    /**根据备忘录恢复到以前的状态**/
    public void restoreMemento(Memento m) {this.setState(m.getState());}

}
/**备忘录**/
public class Memento{
   int state;
}
/**备忘录管理**/
public class MementoBook{
    List<Memento> memList;

    public void setMemento(Memento m) {memList.add(m);}

    public Memento getCurrentMemento() {return memList.get(memList.size());}
    
    public Memento popupMemento() {
        Memento memento = memList.get(memList.size());
        memList.remove(memList);
        return memento;
    }
}

```
可以配合原型模式，当用户状态需要备份时，将当前用户的属性clone并保存下来。待恢复时用这份clone记录即可。


### 状态模式	xxxState
```java
class Test{
  public void main(String[] args){
    //初始化状态
    Context context = new Context();
    //切换状态
    context.handle();
    //..
    //切换状态
    context.handle();
  }
}


//抽象状态类
abstract class State {
    public abstract void handle(Context context);
}


//环境类
class Context {
private State state;
//定义环境类的初始状态
public Context() {this.state = new Begin();}
//设置新状态
public void setState(State state) {this.state = state;}
//读取状态
public State getState() {return (state);}
//对请求做处理
public void handle() {state.handle(this);}
}

//具体状态Begin类
class Begin extends State {
    public void handle(Context context) {
        System.out.println("当前状态是 Begin.");
        //执行完该状态后，需要自动切换到下一个状态
        context.setState(new Finish());
    }
}
//具体状态Finish类
class Finish extends State {
    public void handle(Context context) {
        System.out.println("当前状态是 Finish.");
        //执行完该状态后，需要自动切换到下一个状态
        context.setState(new Begin());
    }
}
```

### 访问者模式	xxxVisitor
### 中介者模式	xxxMediator



