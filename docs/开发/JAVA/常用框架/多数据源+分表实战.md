# Mysql多数据源+分表分库实战

#### 写在前面
在使用分库分表之前，应该先看看使用缓存、添加索引、读写分离等方法能不能解决性能问题。  
若以上方法都不能根本解决问题，才考虑分库分表。

* 热数据（经常查询）、数据量较小、基础数据：使用缓存
* 数据量较大、业务数据：添加索引、读写分离

像Redis、Elastic Search，他们自带数据分片的解决方案。  
例如Redis Cluster使用的是一种叫Hash slot（哈希槽）的分片算法；  



#### 参考资料

dynamic-datasource使用文档：[https://www.kancloud.cn/tracy5546/dynamic-datasource/2264611](https://www.kancloud.cn/tracy5546/dynamic-datasource/2264611)  
mybatis-plus官方文档：[https://baomidou.com/](https://baomidou.com/)  
【CSDN】Sharding-JDBC 实战（史上最全）：[https://blog.csdn.net/crazymakercircle/article/details/123420859](https://blog.csdn.net/crazymakercircle/article/details/123420859)  
Shardingsphere官方文档：[https://shardingsphere.apache.org/document/current/cn/overview/](https://shardingsphere.apache.org/document/current/cn/overview/)


#### 用到的框架

* druid
* dynamic-datasource
* shardingjdbc
* mybatis-plus



##### 1. 多数据源配置（mybatis-plus + dynamic-datasource）

**建表**

假设现在有两个数据库：dyz、dyz2  
dyz库有5张表：
* student
* student_1
* student_2
* student_3
* student_4
* student_5
dyz2库有1张表：
* student

表结构都一样。建表语句如下：
```sql
CREATE TABLE `student` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '名称',
  `age` int DEFAULT NULL COMMENT '年龄',
  `classes` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '所属班级',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**创建SpringBoot项目**

过程略。

**添加依赖&配置**
> 注意使用的版本号，特别是dynamic-datasource

maven.xml
```xml
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.24</version>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.5.2</version>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.31</version>
        </dependency>

        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>dynamic-datasource-spring-boot-starter</artifactId>
            <version>3.1.1</version>
        </dependency>

        <dependency>
            <groupId>org.apache.shardingsphere</groupId>
            <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
            <version>4.1.1</version>
        </dependency>
```



application.yml 
```yaml
server:
  port: 8080

spring:
  application:
    name: sharding-demo
  datasource:
    dynamic:
      primary: dyz #默认使用哪个数据库
      strict: false #true：未匹配到数据源则抛异常 ；false：未匹配到数据源则使用默认数据源
      datasource:
        #数据库1
        dyz:
          driverClassName: com.mysql.cj.jdbc.Driver
          url: jdbc:mysql://localhost:3306/dyz?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai&zeroDateTimeBehavior=convertToNull&allowMultiQueries=true&rewriteBatchedStatements=true&useAffectedRows=true
          username: root
          password: 123456
        #数据库2
        dyz2:
          driverClassName: com.mysql.cj.jdbc.Driver
          url: jdbc:mysql://localhost:3306/dyz2?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai&zeroDateTimeBehavior=convertToNull&allowMultiQueries=true&rewriteBatchedStatements=true&useAffectedRows=true
          username: root
          password: 123456
```

**编写Entity、Mapper、Service、Controller层代码**
略

**Service层切换数据源的写法**
```java
@Service
public class StudentServiceImpl implements StudentService{
    @Autowired
    private StudentMapper studentMapper;

    //使用默认的数据源
    @Override
    public void insert(Student student) {
        studentMapper.insert(student);
    }

    //使用dyz2数据源
    @Override
    @DS("dyz2")
    public void insert2(Student student) {
        studentMapper.insert(student);
    }
}
```

我们可以通过在Service层使用@DS注解，选择我们需要操作的数据库（dyz.student or dyz2.student）。  
至此，多数据库切换已经完成。  
假设之后我们发现，student数据量太大，dyz库仅用一个表保存不够，需要分别保存到4个分表中（student_1,student_2,student_3,student_4），  
怎么实现呢？继续往下看。




##### 2. 分表配置

**在dyz库新建4张子表：student_1,student_2,student_3,student_4**

略，参考上面student表的建表语句。

**增加一个application-sharding-dyz.yml**
```yml
spring:
  shardingsphere:
    datasource:
      names: dyz-sharding
      dyz-sharding:
          initial-size: 5
          min-idle: 1
          max-active: 3000
          max-wait: 9000
          time-between-eviction-runs-millis: 60000
          min-evictable-idle-time-millis: 300000
          validation-query: SELECT 'x'
          test-while-idle: true
          test-on-borrow: false
          test-on-return: false
          pool-prepared-statements: true
          max-pool-prepared-statement-per-connection-size: 3000
          filters: stat,wall,log4j
          log-abandoned: true
          remove-abandoned: true
          remove-abandoned-timeout: 180
          type: com.zaxxer.hikari.HikariDataSource
          driverClassName: com.mysql.cj.jdbc.Driver
          jdbcUrl: jdbc:mysql://localhost:3306/dyz?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai&zeroDateTimeBehavior=convertToNull&allowMultiQueries=true&rewriteBatchedStatements=true&useAffectedRows=true
          username: root
          password: 123456

    sharding:
      tables:
        #student表的分表配置
        student:
          #主键生成规则
          key-generator:
            column: id
            type: SNOWFLAKE
          #inline表达式(groovy)
          actual-data-nodes: dyz-sharding.student_$->{1..4}
          #分表策略：按照班级（classes）分表，一共有4个班级
          table-strategy:
            inline:
              sharding-column: classes
              #inline表达式(groovy)
              algorithm-expression: student_${classes}

# 打印执行的sql语句日志
#spring.shardingsphere.props.sql.show=true
```

> 更多shardingjdbc可配置参数详见：SpringBootConfiguration类

**在application.yml增加以下配置**
```yml
# 启动时加载application-sharding-dyz.yml文件
spring:
  profiles:
    active: sharding-dyz
```

**增加一个配置类**

```java
@Configuration
@AutoConfigureBefore({DynamicDataSourceAutoConfiguration.class, SpringBootConfiguration.class})
public class DataSourceConfiguration {

    /**
     * 分表数据源名称
     */
    public static final String SHARDING_DATA_SOURCE_NAME = "sharding";

    @Autowired
    private DynamicDataSourceProperties dynamicDataSourceProperties;

    @Lazy
    @Resource
    DataSource shardingDataSource;

    /**
     * 将shardingDataSource放到了多数据源（dataSourceMap）中
     * 注意有个版本的bug，3.1.1版本 不会进入loadDataSources 方法，这样就一直造成数据源注册失败
     */
    @Bean
    public DynamicDataSourceProvider dynamicDataSourceProvider() {
        Map<String, DataSourceProperty> datasourceMap = dynamicDataSourceProperties.getDatasource();
        return new AbstractDataSourceProvider() {
            @Override
            public Map<String, DataSource> loadDataSources() {
                Map<String, DataSource> dataSourceMap = createDataSourceMap(datasourceMap);
                // 将 shardingjdbc 管理的数据源也交给动态数据源管理
                dataSourceMap.put(SHARDING_DATA_SOURCE_NAME, shardingDataSource);
                return dataSourceMap;
            }
        };
    }

    /**
     * 将动态数据源设置为首选的
     * 当spring存在多个数据源时, 自动注入的是首选的对象
     * 设置为主要的数据源之后，就可以支持shardingjdbc原生的配置方式了
     *
     * @return
     */
    @Primary
    @Bean
    public DataSource dataSource(DynamicDataSourceProvider dynamicDataSourceProvider) {
        DynamicRoutingDataSource dataSource = new DynamicRoutingDataSource();
        dataSource.setPrimary(dynamicDataSourceProperties.getPrimary());
        dataSource.setStrict(dynamicDataSourceProperties.getStrict());
        dataSource.setStrategy(dynamicDataSourceProperties.getStrategy());
        dataSource.setProvider(dynamicDataSourceProvider);
        dataSource.setP6spy(dynamicDataSourceProperties.getP6spy());
        dataSource.setSeata(dynamicDataSourceProperties.getSeata());
        return dataSource;
    }
}

```

**在启动类增加两个注解**
```java
@MapperScan("org.example.mapper")
@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) //增加
@EnableConfigurationProperties(DynamicDataSourceProperties.class)  //增加
public class Main {
    public static void main(String[] args) {
        SpringApplication.run(Main.class, args);
    }
}
```

至此，分表配置已经完毕。我们在Service层添加插入数据到分表的方法。

```java
@Service
public class StudentServiceImpl implements StudentService{
    @Autowired
    private StudentMapper studentMapper;
    @Override
    public void insert(Student student) {
        studentMapper.insert(student);
    }

    @Override
    @DS("dyz2")
    public void insert2(Student student) {
        studentMapper.insert(student);
    }

    //添加
    @Override
    @DS("sharding")
    public void insertSharding(Student student) {
        studentMapper.insert(student);
    }

}

```

调用insertSharding()时你会发现，classes = 1的会被插入到student_1表，classes = 2的会被插入到student_2表...如此类推。
至此，分表的开发已经完成。
现在的数据库连接池，使用的是SpringBoot默认的Hikari，如果我们想换成Druid的，需要怎么配置呢？


###### *** 使用其他分片策略

在“2.分片配置”中，我们使用了“行表达式(inline)”作为分片策略；事实上，Sharding-jdbc支持5种分片策略：

* 标准分片策略 - StandardShardingStrategy  
    允许设置单个分片键，用以匹配sql中的= 、 in 、> 、< 、 between..and 语句并作出分片操作。  
* 复合分片策略 - ComplexShardingStrategy  
    允许设置多个分片键，用以匹配sql中的= 、 in 、> 、< 、 between..and 语句并作出分片操作。  
* 行表达式分片策略 - InlineShardingStrategy  
    允许使用groovy表达式，设置单个分片键，用以匹配sql中的= 、 in语句并作出分片操作。  
    不支持范围查询（> 、< 、between...and）的分片操作，默认会查所有分表，效率会比较低。
* Hint分片策略 - HintShardingStrategy  
    通过Hint而非SQL解析的方式进行分片的策略
* 不分片策略 - NoneShardingStrategy  
    不分片

> 关于groovy表达式  
> 大文章...自己百度吧


现在我们尝试使用标准分片策略 - StandardShardingStrategy 来配置分片策略。

**创建标准分表策略类**
```java
/**
 * 针对= 、 in 查询条件的分表算法
 * @author : dongyz8
 * @Date : 2022/12/30 10:51
 **/
public class DyzPreciseShardingAlgorithm implements PreciseShardingAlgorithm<String> {

    /**
     *
     * @param tableNames 分表名列表。 student_1,student_2,...
     * @param shardingValue 分片键的值
     * @return
     */
    @Override
    public String doSharding(Collection<String> tableNames, PreciseShardingValue<String> shardingValue) {
        if(null != tableNames && tableNames.size()!=0){
            for(String tableName:tableNames){
                String suffix = tableName.substring(tableName.lastIndexOf("_"));
                if(suffix.equals(shardingValue.getValue())){
                    return tableName;
                }
            }
        }
        throw new UnsupportedOperationException();
    }
}
```

**修改yml的配置**
application-sharding-dyz.yml
```yml
#student表
    sharding:
      tables:
        student:
          key-generator:
            column: id
            type: SNOWFLAKE
          actual-data-nodes: dyz-sharding.student_$->{1..4}
          table-strategy:
#            inline:
#              sharding-column: classes
#              algorithm-expression: student_${classes}
            standard:
              sharding-column: classes
              precise-algorithm-class-name: org.example.config.DyzPreciseShardingAlgorithm #若使用standard，必填
              range-algorithm-class-name:
```

修改后，实际分表效果与inline一样。

> 上面介绍了如何配置分片策略。在配置前，我们应该如何选择分片算法呢？
> 分片算法有以下几种：
> * 

##### 3. Druid配置 

暂略。

##### 4. 广播表、绑定表配置

**广播表（Broadcast Table）**
存在于所有的数据源中的表，表结构和表中的数据在每个数据库中均完全一致。  
一般是为字典表或者配置表。

某个表一旦被配置为广播表：  
保存时，每个数据库都会插入相同的数据；  
查询时，会随机的选择一个数据源进行查询；  

配置：

```yml
spring:
  shardingsphere:
    sharding:
      broadcast-tables:
        - t_dictionary #广播表名称
        - t_config #另一张广播表

```

**绑定表（Binding Table）**
在业务中，我们会常常遇到主表与明细表，比如t_order,t_order_item  
假设主表t_order有两张：t_order_1,t_order_2  
明细表t_order_item有两张：t_order_item_1,t_order_item_2  
它们都使用同一个分片键：t_order_id  
那么我们可以将这主表与明细表配置成绑定关系。  

假设我们要执行以下关联查询：

```sql
select main.*,sub.* from t_order main,t_order_item sub where main.t_order_id = sub.t_order_id;
```

没配置时，会执行4条查询：
```sql
select main.*,sub.* from t_order_1 main,t_order_item_1 sub where main.t_order_id = sub.t_order_id;
select main.*,sub.* from t_order_1 main,t_order_item_2 sub where main.t_order_id = sub.t_order_id; # 多余
select main.*,sub.* from t_order_2 main,t_order_item_1 sub where main.t_order_id = sub.t_order_id; # 多余
select main.*,sub.* from t_order_2 main,t_order_item_2 sub where main.t_order_id = sub.t_order_id;
```

配置后，只会执行2条查询：
```sql
select main.*,sub.* from t_order_1 main,t_order_item_1 sub where main.t_order_id = sub.t_order_id;
select main.*,sub.* from t_order_2 main,t_order_item_2 sub where main.t_order_id = sub.t_order_id;
```

配置:

```yml

```



##### 5. 读写分离、主从复制配置