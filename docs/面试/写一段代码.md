# 写一段代码 


#### 多线程有几种写法

1. 最原始的写法
```java
/**
 * 处理多线程任务（无返回值）
 * 使用Runnable
 * @author : dongyz8
 * @Date : 2023/5/19 11:58
 **/
public static void main(String[] args) {
        //需要定义：
        // 1个计数器（CountDownLatch）
        // 1个线程池（ExecutorService）
        // 10个无返回值的任务（Runnable）

        int TASK_NUM = 10;
        //计数器
        CountDownLatch cdl = new CountDownLatch(TASK_NUM);
        //定义10个任务
        List<Runnable> taskList = new ArrayList<>();
        for(int i=0;i<TASK_NUM;i++){
            int finalNum = i;
            taskList.add(() -> {
                try {
                    Thread.sleep(finalNum * 1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("==========执行完毕！" + finalNum);
                cdl.countDown();
            });
        }
        //多线程执行任务
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        for(Runnable task:taskList){
            threadPool.execute(task);
        }
        //等待所有任务执行完毕
        System.out.println("==========wait!");
        try {
            cdl.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        //最后记得关闭线程池
        threadPool.shutdown();
        System.out.println("==========finish!");
    }


```


2. 比较原始的写法

```java
/**
 * 处理多线程任务（有返回值）
 * FutureTask + Callable
 * @author : dongyz8
 * @Date : 2023/5/19 14:06
 **/
public static void main(String[] args) {
        //需要定义：
        // 1个计数器（CountDownLatch）
        // 1个线程池（ExecutorService）
        // 10个有返回值的任务（FutureTask + Callable）


        int TASK_NUM = 10;
        //计数器
        CountDownLatch cdl = new CountDownLatch(TASK_NUM);
        //定义10个任务
        List<FutureTask<Integer>> taskList = new ArrayList<>();
        for(int i=0;i<TASK_NUM;i++){
            int finalNum = i;
            taskList.add(new FutureTask<>(() -> {
                try {
                    Thread.sleep(finalNum * 1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("==========执行完毕！" + finalNum);
                cdl.countDown();
                return finalNum;
            }));
        }
        //多线程执行任务
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        for(FutureTask task:taskList){
            threadPool.execute(task);
        }
        //等待所有任务执行完毕
        System.out.println("==========wait!");
        try {
            cdl.await();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        //取出计算结果并汇总。这里只是简单地求和。
        int sum = 0;
        for(FutureTask<Integer> task:taskList){
            try {
                sum+=task.get();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } catch (ExecutionException e) {
                throw new RuntimeException(e);
            }
        }
        System.out.println("==========result:"+sum);
        //最后记得关闭线程池
        threadPool.shutdown();
        System.out.println("==========finish!");
    }

````


3. 推荐的写法

```java
/**
 * 处理多线程任务（有返回值）
 * CompletionService + Callable
 * @author : dongyz8
 * @Date : 2023/5/19 14:06
 **/
public static void main(String[] args) {
        //需要定义：
        // 不用计数器（CountDownLatch）
        // 1个线程池（CompletionService代替ExecutorService）
        // 10个有返回值的任务（Callable）
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        CompletionService<Integer> cService = new ExecutorCompletionService<Integer>(threadPool);
        int TASK_NUM = 10;
        //定义10个任务
        List<Callable<Integer>> taskList = new ArrayList<>();
        for(int i=0;i<TASK_NUM;i++){
            int finalNum = i;
            taskList.add(() -> {

                return finalNum;
            });
        }

        //执行任务
        for(Callable task:taskList){
            cService.submit(task);
        }

        //不用等到所有任务出结果才汇总
        //先计算出结果的就可以先汇总
        int sum = 0;
        for(int i=0;i<TASK_NUM;i++){
            try {
                int result = cService.take().get();
                System.out.println("==========执行完毕！" + result);
                sum+= result;
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } catch (ExecutionException e) {
                throw new RuntimeException(e);
            }
        }
        System.out.println("==========result:"+sum);
        //最后记得关闭线程池
        threadPool.shutdown();
        System.out.println("==========finish!");
    }
```


4. 推荐的写法


```java
/**
 * 处理多线程任务（有返回值）
 * CompletableFuture + Callable
 * @author : dongyz8
 * @Date : 2023/5/19 14:06
 **/
    public static void main(String[] args) {
        //需要定义：
        // 不用计数器（CountDownLatch）
        // 不用线程池（CompletableFuture自带线程池(ForkJoinPool.commonPool())）
        // 10个有返回值的任务（Callable）
        ExecutorService threadPool = Executors.newFixedThreadPool(5);
        CompletionService<Integer> cService = new ExecutorCompletionService<Integer>(threadPool);
        int TASK_NUM = 10;
        //定义10个任务
        AtomicInteger sum = new AtomicInteger();
        List<CompletableFuture<Integer>> taskList = new ArrayList<>();
        for(int i=0;i<TASK_NUM;i++){
            int finalNum = i;
            //执行任务
            taskList.add(CompletableFuture.supplyAsync(() -> {
                try {
                    Thread.sleep(finalNum * 1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println(Thread.currentThread().getId()+"==========执行完毕！" + finalNum);
                return finalNum;
            }).thenApply(sum::addAndGet));
        }


        System.out.println("==========等待汇总结果！");
        CompletableFuture
                .allOf(taskList.toArray(new CompletableFuture[taskList.size()]))
                .join();
        System.out.println("==========result:"+sum);
        //最后记得关闭线程池
        threadPool.shutdown();
        System.out.println("==========finish!");
    }
```