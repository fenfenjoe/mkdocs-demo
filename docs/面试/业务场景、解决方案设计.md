# 业务场景、解决方案



### 业务场景：电商订单模块


#### 订单状态流转（状态机）

首先，一般的订单流程如下：

客户提交订单 -> (订单待支付) -> 客户支付订单 -> (订单待发货) -> 商户发货 -> (订单待确认) -> 物流确认收货 -> (订单已完成)

提交前，需要对订单做一些校验（库存校验、优惠券校验）；都通过，则锁定库存，修改订单状态。


#### 订单超时自动取消

电商系统一般会设计一个，过了一段时间未支付、则自动取消订单的功能。


实现方式有以下几种：
* 延时队列（MQ）
* Redis
* 定时任务（Schedular、xxljob）

下面讲一下Redis的具体实现方法。

0. 需要修改redis.conf配置文件

```
//...
//将notify-keyspace-events属性值改为“Ex”
notify-keyspace-events Ex

```


1. 订单提交后，往Redis保存该订单的ID，并设置过期时间（假设为15分钟）

```
  restTemplate.opsForValue().set(K key, V value, long time, TimeUnit timeunit);
```

2. 15分钟过后，Redis会将过期的这条数据发送到一个channel中，此时我们定义一个Listener，负责监听并处理这份过期未支付的订单。

```java
    public class RedisExpiredListener extends KeyExpireationEventMessageListener{
        @Override
        public void onMessage(Message message,@Nullable byte[] pattern){
            //1.解锁库存
            //2.修改订单状态为“已取消”。
            //...
        }

    }
```

3. 同时，还要添加Listener到Redis配置类中

```java
    @Configuration
    public class RedisConfig{

        //....

        @Bean
        public RedisMessageListenerContainer redisMessageListenerContainer(){
            RedisMessageListenerContainer container = new RedisMessageListenerContainer();
            container.setConnectionFactory(connectionFactory);
            return container;
        }

        @Bean
        public RedisExpiredListener redisExpiredListener(){
            return new RedisExpiredListener(redisMessageListenerContainer());
        }
    }
```

4. 完成


### 数据同步场景

数据同步场景非常多。例如：
* mysql的表与表之间
* mysql到oracle
* mysql到redis
* mysql到excel
* mysql到es
* mysql到kafka
* ...


同步的方式有两种：
* 全量同步，即将所有数据从A全部拷贝至B
* 增量同步，仅拷贝新的数据

全量同步比较简单，如库与库之间可以通过导入、导出数据进行同步。

对于增量同步，目前常见的数据同步解决方案：

* 双写
    * 同步双写：在代码中，当往A库插入一条数据后，往B库也插入同样的数据
    * 异步双写：使用MQ。在代码中，当往A库插入一条数据后，往MQ写入一条插入消息。

* CDC（通过日志抓取数据的变化，并同步）
    * canel（阿里的中间件，仅支持mysql）
    * databus
    * Debezium

* 定时任务(定期查出A库中新的数据（比如每天），并更新到B库中)
    * quartz
    * xxl-job
    * elasticjob
    

### 批量提交任务，提交后，后台异步执行
问题1：扩容机制？  
问题2：多个微服务的情况下，如何做到任务的负载均衡？  

**解决方案1**  
选择多条任务，提交后，修改任务状态为“执行中”  
将每条任务都发送一条message到mq（作为分布式队列，多个微服务从队列中取出任务执行）  
微服务监听任务的topic，当有message需要处理，处理前先获取分布式锁（redis），然后放到线程池异步执行。（通过线程池控制每一个微服务执行任务的并发量）  

**解决方案2**  
选择多条任务，提交后，修改任务状态为“执行中”  
创建一个定时任务，定期轮询查出任务状态为“执行中”的任务  
处理前先获取分布式锁（redis），然后放到线程池异步执行  


