# 中间件

中间件：为应用程序提供服务的软件。

#### 应用程序一般有哪些需求？

* 路由、反向代理：Nginx
* 提供API（RPC）：Dubbo
* 消息队列：Kafka、RocketMQ、RabbitMQ、Zookeeper、Redis
* 配置：Nacos、Zookeeper
* 事务：Zookeeper、Redis
* 任务调度
* 数据管理
    * 缓存：Redis、Memcache
    * 数据库：Mysql、Oracle
    * 文件系统：OSS
* 系统监控：Zabbix

>一些需求通过中间件实现，一些则是通过框架实现。
>中间件与框架的区别：中间件提供API，可部署；框架则是需要开发者整合到应用的代码中，才能使用其功能。

#### 有哪些中间件？

* web容器：tomcat、websphere、jboss、weblogic
* 数据库
* 消息队列：Kafka、RocketMQ、RabbitMQ
* 缓存：Redis、Memcache
* 负载均衡：Nginx
* 文件系统：OSS、Zookeeper、Hadoop
* 注册中心：Eureka、Nacos

单机情况下：

|中间件          |通信层 |线程数             |最大QPS           |开发语言|
|---            |---    |---               |---               |---     |
|tomcat         |BIO    |默认200线程，1w连接|                  |Java    |
|jetty          |NIO    |                  |                  |Java     |
|netty          |NIO    |                  |                  |Java     |
|underow        |NIO    |                  |                  |         |
|kafka          |       |                  |10万级            |scala    |
|rocketMQ       |Netty  |                  |10万级            |java     |
|rabbitMQ       |       |                  |万级              |Erlang   |
|Redis          |NIO    |单线程             |百万级            |C        |
|Memcache       |       |||
|Nginx          |       |||
|Zookeeper      |       |||
|Eureka         |       |||
|mysql          |       |||
|oracle         |       |||
|Elastic Searach|       |||

#### 中间件内部一般需要支持什么功能？
* 集群：中间件如何支持分布式的。
* 应用层：中间件是如何提供API的。
    * 数据格式（序列化）：可以理解为参数格式
    * RPC（远程过程调用）：可以理解为应用层报文格式
* 通信层：中间件使用什么通信框架，例如Mina、Netty等。


### 通信层（I/O）
>为什么先讲通信层？
>因为中间件的性能（吞吐量）与通信层有较大关系。

#### 通信层有哪些框架？
参考：[https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html](https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html)

先从比较原始的、操作系统级别的“进程间通信”说起。因为通信层实质解决的就是两个在不同主机上的进程的通信问题。

**进程间通信**

本地的进程间通信有四种方式：
* 消息传递（管道、FIFO、队列）
* 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）
* 共享内存（匿名的和具名的）
* 远程过程调用（Solaris门和Sun RPC）

远程的进程间通信有两种方式：
* UNIX BSD（即Socket）
* UNIX SYSTEM V的TLI（被淘汰，不进行讨论）


**Socket（操作系统原生框架）**

Socket是操作系统提供的一组接口，是**应用层与TCP/IP协议族通信的中间软件抽象层**。
也就是说，中间件可以自己选择应用层协议（HTTP、HTTPS、FTP、SSH等），根据应用层协议封装好报文（例如HTTP报文）后，调用Socket的API即可将其封装成TCP或UDP报文并发送出去。

Socket为两端（服务端、客户端）都提供了函数API。


##### 建立TCP连接、关闭TCP连接
```c++
//用于创建一个socket描述符（socket descriptor）
int socket(int domain, int type, int protocol);
//为socket定义一个地址。地址格式：ip+端口
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
//监听某个socket，backlog对应该socket可以排队的最大连接个数（TCP服务端调用）
int listen(int sockfd, int backlog);
//向某个socket发起连接请求（TCP客户端调用）
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
 //【重要！！！！！】阻塞线程去监听Socket，接收TCP连接请求（TCP服务端接收到请求后，调用accept创建连接，连接成功会返回一个新的已连接socket套接字）
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);


//读写完后需要关闭连接。
int close(int fd);
```

>建立连接之后，就是两端通过流从连接中读写数据的过程（I/O）。
>I/O模型又慢慢的发展出3种模式：
>* BIO（同步阻塞模式）
>* NIO（同步非阻塞模式）
>* AIO（异步模式）

##### BIO（同步阻塞模式）
```c++

//服务端：从套接字读TCP请求数据
//客户端：往套接字写TCP请求数据
read()/write()
readv()/writev()

ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);

ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);

```

![bff5c6ddebb4cd27da4e945e9b163d92.png](en-resource://database/1152:1)
##### NIO（同步非阻塞模式，也称为多路复用模式）
```c++
//select:无差别轮询
//对所有流进行轮询。轮询复杂度为O（n），且有最大连接数限制(每个线程最多可处理1024个连接）
int select(int maxfdpl, fd_set *readset, fd_set *writeset,
    fd_set *exceptset, const struct timeval *timeout);

//poll:忙轮询
//与select的唯一区别就是没有最大连接数限制
int poll(struct pollfd *fds, nfds_t nfds, int timeout);

//epoll:事件驱动轮询
//epoll不用轮询，而是通过事件机制，会把哪个流发生了怎样的I/O事件通知我们，因此轮询复杂度为O(1)
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```


**Java原生框架**
Java BIO（JDK 1.0）
```java
//客户端
Socket socket = new Socket("127.0.0.1", 3333);
while (true) {
   try {
       socket.getOutputStream().write((new Date() + ": hello world").getBytes());
       Thread.sleep(2000);
   } catch (Exception e) {

   }
}

//服务端
ServerSocket serverSocket = new ServerSocket(3333);
while(true){
   Socket socket = serverSocket.accept();
   new Thread(() -> {
       try {
           int len;
           byte[] data = new byte[1024];
           InputStream inputStream = socket.getInputStream();
           // 按字节流方式读取数据
           while ((len = inputStream.read(data)) != -1) {
               System.out.println(new String(data, 0, len));
           }

       } catch (IOException e) {

       }
}
```
>BIO：一个线程，直接监听一个套接字。
>连接成功后，开新线程负责请求的处理。
>即监听：单线程单连接。处理连接：多线程。
>通常配合多线程，使服务器可以同时处理多个连接请求。但是线程数有限（大概6000以下），不能同时处理大量请求。

Java NIO（Java SE 1.4）
```java
//服务端（核心代码）
//大致流程：
//定义了两个Selector
Selector serverSelector = Selector.open();
Selector clientSelector = Selector.open();

//serverSelector负责监听ACCEPT请求
ServerSocketChannel listenerChannel = ServerSocketChannel.open();
listenerChannel.socket().bind(new InetSocketAddress(3333));
listenerChannel.configureBlocking(false);
listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);
//当监听到ACCEPT请求后
new Thread( ()->{
    while (true) {
        if (serverSelector.select(1) > 0) {
         Set<SelectionKey> set = serverSelector.selectedKeys();
            Iterator<SelectionKey> keyIterator = set.iterator();
                while (keyIterator.hasNext()) {
                    SelectionKey key = keyIterator.next();
                    if (key.isAcceptable()) {
                      try {
                               // 建立连接，此时不需要创建一个线程去读数据，而是先注册到clientSelector，等服务端接收到READ请求后，便clientSelector会监听到并处理。
                               SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();
                               clientChannel.configureBlocking(false);
                               clientChannel.register(clientSelector, SelectionKey.OP_READ);
                           } finally {
                               keyIterator.remove();
                           }
                       }
                  }
           }
      }
}).start();

//clientSelector负责监听READ请求
new Thread( ()->{
    while (true) {
       // (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为 1ms
       if (clientSelector.select(1) > 0) {
           Set<SelectionKey> set = clientSelector.selectedKeys();
           Iterator<SelectionKey> keyIterator = set.iterator();
           while (keyIterator.hasNext()) {
               SelectionKey key = keyIterator.next();
               if (key.isReadable()) {
                   try {
                       SocketChannel clientChannel = (SocketChannel) key.channel();
                       ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                       // (3) 面向 Buffer
                       clientChannel.read(byteBuffer);
                       byteBuffer.flip();
                       System.out.println(
                               Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());
                   } finally {
                       keyIterator.remove();
                       key.interestOps(SelectionKey.OP_READ);
                   }
               }
           }
       }
    }
}).start();

```
>NIO：也叫I/O多路复用机制，底层通过epoll函数实现
>可见NIO的API比较复杂。
>Netty 的出现很大程度上改善了 JDK 原生 NIO 所存在的一些让人难以忍受的问题。

Java AIO（Java SE 1.7）

**netty**
netty是一套NIO框架，底层对Java NIO进行封装。

**mina**
mina是一套NIO框架，底层对Java NIO进行封装。

**Grizzly**
Grizzly是一套NIO框架，底层对Java NIO进行封装。